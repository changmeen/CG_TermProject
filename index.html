<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - glTF loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">
            권순완 류창민 박찬빈 정호진<br />
            Computer Graphics TermProject Pinball Game<br />
            Space - launch ball, z - left flipper, / - right flipper
    </div>
    <div id="score_div"></div>
    <div class="wrap_box">
        <div class="name_box">
            <span class="Score_id">score</span>
            <span id="Score">0</span>
        </div>
    </div>
    </div>

    <script type="module">
        import * as THREE from '../build/three.module.js';
        import {
            GLTFLoader
        } from './jsm/loaders/GLTFLoader.js';
        import {
            GUI
        } from './jsm/libs/dat.gui.module.js';
        import {
            OrbitControls
        } from './jsm/controls/OrbitControls.js';
        import {
            BufferGeometryUtils
        } from './jsm/utils/BufferGeometryUtils.js';
        import '../build/bllem-cannon.js';

        var camera, scene, renderer, world, mass, body, shape, geometry, material, mesh, flipperleft, flipperright, field, bumperleft, bumperright, object, c, h;
        var count = 0;
        var check1 = 1,
            check2 = 1,
            check3 = 1;
        const timeStep = 1 / 120;

        const clock = new THREE.Clock();

        const manager = new THREE.LoadingManager();

        const loadered = new THREE.TextureLoader();

        var loadingDone = false;

        var loaded = {};

        var balls = {};
        var ballscount = 0;
        var balllaunched = false;

        var bodies = {}

        const cannonMaterials = {};

        cannonMaterials["mat"] = new CANNON.Material();
        cannonMaterials["groundMaterial"] = new CANNON.Material();
        cannonMaterials["bumperMaterial"] = new CANNON.Material();
        cannonMaterials["slingshotMaterial"] = new CANNON.Material();

        const mat_ground = new CANNON.ContactMaterial(cannonMaterials["groundMaterial"], cannonMaterials["mat"], {
            friction: 0.0,
            restitution: 0.2
        });
        const mat_bumper = new CANNON.ContactMaterial(cannonMaterials["bumperMaterial"], cannonMaterials["mat"], {
            friction: 0.0,
            restitution: 0.8
        });
        const mat_slingshot = new CANNON.ContactMaterial(cannonMaterials["slingshotMaterial"], cannonMaterials["mat"], {
            friction: 0.4,
            restitution: 0.8
        });
        const mat_flipper = new CANNON.ContactMaterial(cannonMaterials["flipperMaterial"], cannonMaterials["mat"], {
            friction: 0.0,
            restitution: 1.5
        });

        const matStdObjects = new THREE.MeshLambertMaterial({
            color: 0xffffff
        });

        const response = await fetch('gltflist.json');
        const data = await response.text();
        var gltflist = JSON.parse(data);

        var models = {};

        flipperleft = {
            max: 22.5,
            min: -10,
            current: 0,
            speed: 0,
            currentspeed: 0
        }
        w

        flipperright = {
            max: -60,
            min: -57,
            current: 0,
            speed: 0,
            currentspeed: 0,
            lastspeed: 0,
            startpoint: 0,
            pointdiff: 0
        }

        var zpressed = false;
        var slashpressed = false;

        init();
        initCannon();
        gameLoop();

        function initCannon() {

            const radius = 0.5; // m
            const damping = 0.01;

            world = new CANNON.World();
            world.gravity.set(0, -30, 9.82); // m/s²
            world.broadphase = new CANNON.NaiveBroadphase();
            //world.solver.iterations = 10;

            shape = new CANNON.Sphere(radius);
            mass = 1;
            body = new CANNON.Body({
                mass: 5,
                material: cannonMaterials["mat"],
                ccdSpeedThreshold: 0,
                position: new CANNON.Vec3(9.25, 0, 10) // m
            });

            body.addShape(shape);
            body.linearDamping = damping;
            body.velocity.set(0, 0, 0);
            world.addBody(body);

            // Create a plane
            const groundBody = new CANNON.Body({
                mass: 0,
                material: cannonMaterials["groundMaterial"]
            });
            const groundShape = new CANNON.Plane();
            groundBody.addShape(groundShape);
            //world.addBody(groundBody);

            world.addContactMaterial(mat_ground);
            world.addContactMaterial(mat_bumper);
            world.addContactMaterial(mat_slingshot);

            animate();

        }

        function init() {

            const container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 10);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            const light = new THREE.AmbientLight(0x404040); // soft white light

            const spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(0, 20, -50);
            scene.add(spotLight);

            checkLoaded();

            Object.keys(gltflist).forEach(key => {
                loaded[key] = new loadmodel(gltflist[key].modelpath, gltflist[key].modelfile, gltflist[key].size, gltflist[key].smooth, key, gltflist[key].posx, gltflist[key].posy, gltflist[key].posz, gltflist[key].rotation, gltflist[key].meshmat, gltflist[key].mass);
            });

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render); // use if there is no animation loop
            controls.minDistance = 2;
            controls.maxDistance = 40;
            controls.target.set(0, 0, 0);
            controls.update();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener("keydown", event => {
                if (event.isComposing || event.keyCode === 90) {
                    if (!zpressed) {
                        flipperleft.speed = -14;
                        zpressed = true;
                    }
                }
                if (event.isComposing || event.keyCode === 191) {
                    if (!slashpressed) {
                        Math.round(THREE.Math.radToDeg(bodies.h.quaternion.y));
                        flipperright.speed = 14;
                        slashpressed = true;
                    }
                }
                if (event.isComposing || event.keyCode === 32) {
                    if (balllaunched == false) {
                        body.velocity.set(0, 0, -27.5);
                        balllaunched = true;
                    }
                }

            });
            window.addEventListener("keyup", event => {
                if (event.isComposing || event.keyCode === 90) {
                    zpressed = false;
                    flipperleft.speed = 7;
                }
                if (event.isComposing || event.keyCode === 191) {
                    slashpressed = false;
                    flipperright.speed = -7;
                }
            });
        }

        function loadmodel(modelpath, modelfile, meshsize, smooth, scenekey, posx, posy, posz, rotation, meshmat, modelmass) {

            this.smooth = smooth;

            this.loader = new GLTFLoader(manager).setPath(modelpath);
            this.loader.load(modelfile, function(gltf) {

                this.gltf = gltf;
                this.gltf.scene.traverse(function(child) {
                    if (child.isMesh) {
                        child.material = matStdObjects;
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.doubleSided = false;
                    }
                });

                this.gltf.scene
                var glTFGeometry;
                var scale;
                // Might be used someday, have to look into bufferGeometry

                this.gltf.scene.traverse(function(child) {
                    if (child.isMesh) {
                        glTFGeometry = new THREE.Geometry().fromBufferGeometry(child.geometry);
                        scale = child.scale;
                    }
                });

                var vertices = [],
                    faces = [];

                // Add vertices
                for (let i = 0; i < glTFGeometry.vertices.length; i++) {
                    let x = scale.x * glTFGeometry.vertices[i].x;
                    let y = scale.y * glTFGeometry.vertices[i].y;
                    let z = scale.z * glTFGeometry.vertices[i].z;

                    vertices.push(new CANNON.Vec3(x, y, z));
                }

                for (let i = 0; i < glTFGeometry.faces.length; i++) {
                    let a = glTFGeometry.faces[i].a;
                    let b = glTFGeometry.faces[i].b;
                    let c = glTFGeometry.faces[i].c;

                    faces.push([a, b, c]);
                }

                shape = new CANNON.ConvexPolyhedron(vertices, faces);

                var gltfBody = new CANNON.Body({
                    mass: modelmass,
                    material: cannonMaterials[meshmat],
                    position: new CANNON.Vec3(posx, posy, posz) // m
                });

                const gltfShape = glTFGeometry;
                gltfBody.addShape(shape);

                bodies[scenekey] = gltfBody;

                this.gltf.scene.castShadow = true;
                this.gltf.scene.receiveShadow = true;
                scene.add(this.gltf.scene);

                const radians = THREE.Math.degToRad(rotation);
                const quaternion = new THREE.Quaternion();
                gltfBody.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), radians);

                this.gltf.scene.position.copy(gltfBody.position);
                this.gltf.scene.quaternion.copy(gltfBody.quaternion);
                world.addBody(bodies[scenekey]);

                var ballLight = new THREE.PointLight(0xCFFFE5, 1, 5);

                bodies.o.addEventListener("collide", function(e) {
                    console.log("Collision Detection at Bumper2")
                    if (check1 == 1) {
                        score += 100;
                        console.log("score : " + score);
                        check1 = 0;
                    }
                    ballLight.position.set(bodies.o.position.x, bodies.o.position.y + 1, bodies.o.position.z);
                    scene.add(ballLight);
                    setTimeout(function() {
                        scene.remove(ballLight);
                        check1 = 1;
                    }, 500);
                });

                bodies.p.addEventListener("collide", function(e) {
                    console.log("Collision Detection at Bumper1")
                    if (check2 == 1) {
                        count++;
                        console.log("score : " + count);
                        check2 = 0;
                    }
                    ballLight.position.set(bodies.p.position.x, bodies.p.position.y + 1, bodies.p.position.z);
                    scene.add(ballLight);
                    setTimeout(function() {
                        scene.remove(ballLight);
                        check2 = 1;
                    }, 500);
                });

                bodies.q.addEventListener("collide", function(e) {
                    console.log("Collision Detection at Bumper3")
                    if (check3 == 1) {
                        count++;
                        console.log("score : " + count);
                        check3 = 0;
                    }
                    ballLight.position.set(bodies.q.position.x, bodies.q.position.y + 1, bodies.q.position.z);
                    scene.add(ballLight);
                    setTimeout(function() {
                        scene.remove(ballLight);
                        check3 = 1;
                    }, 500);
                });


            }.bind(this));
        }

        //Check if assets loaded
        function checkLoaded() {
            manager.onStart = function(url, itemsLoaded, itemsTotal) {
                console.log('Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');
            };

            manager.onLoad = function() {
                console.log('Loading complete!');
                loadingDone = true;
                initMachine();
            };

            manager.onProgress = function(url, itemsLoaded, itemsTotal) {
                console.log('Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');
            };

            manager.onError = function(url) {
                console.log('There was an error loading ' + url);
            };
        }

        function initMachine() {
            flipperHinge();
            flipperStartPos();
            createBall();
        }


        function flipperHinge() {
            c = new CANNON.HingeConstraint(bodies.g, bodies.c, {
                pivotA: new CANNON.Vec3(gltflist.c.posx, gltflist.c.posy, gltflist.c.posz),
                axisA: new CANNON.Vec3(0, 1, 0),
                pivotB: new CANNON.Vec3(0, 0, 0),
                axisB: new CANNON.Vec3(0, 1, 0)
            });
            world.addConstraint(c);
            c.enableMotor();
            h = new CANNON.HingeConstraint(bodies.g, bodies.h, {
                pivotA: new CANNON.Vec3(gltflist.h.posx, gltflist.h.posy, gltflist.h.posz),
                axisA: new CANNON.Vec3(0, 1, 0),
                pivotB: new CANNON.Vec3(0, 0, 0),
                axisB: new CANNON.Vec3(0, 1, 0)
            });
            world.addConstraint(h);
            h.enableMotor();

        }

        function flipperStartPos() {
            flipperright.startpoint = Math.round(THREE.Math.radToDeg(bodies.h.quaternion.y));
        }

        //Create ball
        function createBall() {
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.14,
                metalness: 1
            });
            const sphere = new THREE.Mesh(geometry, material);

            scene.add(sphere);
            balls[ballscount] = sphere;
            ballscount++;
            body.addEventListener("collide", function(e) {
                if (e.contact.bj.index == 20 || e.contact.bj.index == 12 || e.contact.bj.index == 1) {
                    count = 0;
                }

                if (e.body.id == "2") {
                    balllaunched = false;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }


        function updatePhysics() {
            world.step(timeStep);
            if (loadingDone) {
                balls[0].position.copy(body.position);
                balls[0].quaternion.copy(body.quaternion);
                loaded.c.gltf.scene.position.copy(bodies.c.position);
                loaded.c.gltf.scene.quaternion.copy(bodies.c.quaternion);
                loaded.h.gltf.scene.position.copy(bodies.h.position);
                loaded.h.gltf.scene.quaternion.copy(bodies.h.quaternion);

            }
        }

        function gameLoop() {
            const delta = clock.getDelta();
            var ticks = Math.round(delta / (1 / 120));

            setTimeout(() => {
                updateFlippers();
                updatePhysics();
                gameLoop();
            }, ticks);
        };

        function updateFlippers() {
            if (loadingDone) {
                //setting previous degree
                var lastcurrent;
                var nowcurrent = Math.round(flipperright.current);
                var currentright;

                if (nowcurrent == 0) {
                    lastcurrent = flipperright.startpoint;
                } else {
                    lastcurrent = nowcurrent;
                }

                //getting current degree
                flipperleft.current = THREE.Math.radToDeg(bodies.c.quaternion.y);
                flipperright.current = THREE.Math.radToDeg(bodies.h.quaternion.y);

                //get current rounded degree
                nowcurrent = Math.round(flipperright.current);

                if (nowcurrent !== lastcurrent) {
                    if (flipperright.lastspeed > 0) {
                        flipperright.pointdiff--;
                    }
                    if (flipperright.lastspeed < 0) {
                        flipperright.pointdiff++;
                    }
                    currentright = flipperright.startpoint + flipperright.pointdiff;
                }

                if (flipperleft.current > flipperleft.max) {
                    if (flipperleft.speed < 0) {
                        flipperleft.speed = 0;
                        c.setMotorSpeed(flipperleft.speed);
                        flipperleft.currentspeed = flipperleft.speed;
                    } else if (flipperleft.speed > 0) {
                        c.setMotorSpeed(flipperleft.speed);
                        flipperleft.currentspeed = flipperleft.speed;
                    }
                } else if (flipperleft.current < flipperleft.min) {
                    if (flipperleft.speed > 0) {
                        flipperleft.speed = 0;
                        c.setMotorSpeed(flipperleft.speed);
                        flipperleft.currentspeed = flipperleft.speed;
                    } else {
                        c.setMotorSpeed(flipperleft.speed);
                        flipperleft.currentspeed = flipperleft.speed;
                    }
                } else if (flipperleft.currentspeed != flipperleft.speed) {
                    c.setMotorSpeed(flipperleft.speed);
                    flipperleft.currentspeed = flipperleft.speed;
                }

                if (currentright < flipperright.max) {
                    if (flipperright.speed > 0) {
                        flipperright.lastspeed = flipperright.speed;
                        flipperright.speed = 0;
                        h.setMotorSpeed(flipperright.speed);
                        flipperright.currentspeed = flipperright.speed;
                    } else if (flipperright.speed > 0) {
                        flipperright.lastspeed = flipperright.speed;
                        h.setMotorSpeed(flipperright.speed);
                        flipperright.currentspeed = flipperright.speed;
                    }
                } else if (currentright > flipperright.min) {
                    if (flipperright.speed < 0) {
                        flipperright.lastspeed = flipperright.speed;
                        flipperright.speed = 0;
                        h.setMotorSpeed(flipperright.speed);
                        flipperright.currentspeed = flipperright.speed;
                    } else if (flipperright.speed > 0) {
                        flipperright.lastspeed = flipperright.speed;
                        h.setMotorSpeed(flipperright.speed);
                        flipperright.currentspeed = flipperright.speed;
                    }
                } else if (flipperright.currentspeed != flipperright.speed) {
                    flipperright.lastspeed = flipperright.speed;
                    h.setMotorSpeed(flipperright.speed);
                    flipperright.currentspeed = flipperright.speed;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            var score = document.getElementById('Score');
            score.innerHTML = count;
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function turnoff() {
            scene.remove(ballLight);
        }
    </script>

</body>

</html>